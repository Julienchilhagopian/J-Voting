= 2.3 New GUI implementation 

====== link:../README.adoc[Summary]

=== GUI Usecase

image:../assets/GUIUseCaseDiagram.png[GUIUseCaseDiagram]

Currently, the GUI enables the user to view a SOC profile (either in rows, columns or wrapped visualization). For the moment the GUI only accepts .soc files already filled.

We plan to allow the user to create a profile through the graphical user interface. In other words, the user should be able to create a profile file, alternatives, voters and complete preferences. Moreover, the user will be able to modify an existing profile by adding some voters (with their preference) and to reorganize preferences (for a strict profile). Therefore, we plan to implement additional methods in the GUI classes.

=== GUI Modeling

image:../assets/GUIMainMenu.png[GUIMainMenu]

We used link:https://wireframesketcher.com/[WireFrame Sketcher]  to design a modeling of our project. You can look at the interactive link:https://github.com/Julienchilhagopian/J-Voting/raw/master/Doc/model/storyboard.pdf[PDF] (download to be able to benefit from the interactions) to better understand our GUI.

The GUI works with a tab system, it is possible to switch from editing to viewing and vice versa for the same file. When you open the application, you will be taken to the profile edition tab. When you click to name the profile, a soc file is created with the current information. It is then possible to modify them by changing the order of the alternatives, adding or deleting alternatives and voters. It is also possible to rename them. 

We can also open an existing file and make the same changes. Each modification is saved in real time on the file. The file is then automatically saved in a defined folder. It is possible to open the view tab to be able to consult a profile.

link:https://en.wikipedia.org/wiki/Nota_bene[NB]: At startup, and as long as the profile name is not filled in, the input boxes are red to indicate that no file is created. When the file name is entered, the file is created and the red disappears from the input boxes.


= MVC pattern applied to J-Voting GUI

We start with an instance of MutableLinearPreference as a model. 

image:../assets/NewGUIClassDiagram.png[NewGUIClassDiagram]

=== *MainGUI*
[cols="1,1", options="header"] 
|===
|Method name
|Explanation 

|Main(String[] args)
| Calls the displayGUI() Method

|displayGUI()
|Â Instanciates the main shell mechanism. 
*Gathers all the differents MVC pieces* :

- Create MutableLinear Preference Instance 

- Create View instance and pass it probably the mainshell.

- Create Controller and pass it the View & Preference.

- The view builds an Edition & Visualisation views and pass them its unique tabFolder.

- Create Edition & Visualisation child controllers and pass them the associated child views *and the common controller* (I don't see otherwise how those two controllers will be able to use the getModel() method declared in controller). 


- Finally calls : 
initEditionView()
initVisualisationView()
initEditionControler()
initVisualisationController()


|===

=== *Controller*
[cols="1,1", options="header"] 
|===
|Method name
|Explanation 

|controller(View v, MutableLinearPreference model)
| Set the parent view and the common model shared by all child controllers


|===


=== *EditionController*
[cols="1,1", options="header"] 
|===
|Method name
|Explanation 

|initEditionView()
| Pass the default model to the view for rendering. This will be necessary in the future to display a default profile when user open the app.

|initEditionControler()
| We add listeners on all the controls present in the default view when we enter the app. 
We link them to each corresponding callbacks. 

|onModifyAlternativeName(Event e)
| We retrieve the id of the Alternative that is being modified. 
Then each time that the user type a letter the name of the alternative is changed in the model (this a proposition, we could say otherwise that we update the model only when user finish typing).

|onModifyVoterName(Event e)
|Each time that the user type a letter the name of the voter is updated in the model (this a proposition, we could say otherwise that we update the model only when user finish typing)


|onDeleteAlternativeBtnClick(SelectionEvent event)
| We retrieve the id of the alternative to be deleted. 
Then we delete the alternative from the preference model. 
And we call a method from the view that delete an Alternative case.  


|onAddAlternativeBtnClick(SelectionEvent event)
| We add a new alternative to the preference model with as name : the text present in the text field (getter on that text field). Then we call a method from the view that add an Alternative case (This might change depending on the SWT usage).  

|===

=== *VisualisationController*
[cols="1,1", options="header"] 
|===
|Method name
|Explanation 

|initVisualisationView()
| Pass the default model to the view for rendering. 

|initVisualisationController()
| We add listeners on all the controls present in the default view when we enter the app. 
We link them to each corresponding callbacks. 

|OnVisualisationTabClick(SelectionEvent event)
| When we enter the visualisation tab we send to the view the current up to date preference model. 

|onColumnBtnClick(SelectionEvent event)
|We call the view function that handle column tab rendering. 
We pass to the view the preference model.

|onRowBtnClick(SelectionEvent event)
|We call the view function that handle row tab rendering. 
We pass to the view the preference model.

|onWrappedBtnClick(SelectionEvent event)
|We call the view function that handle wrapped tab rendering. 
We pass to the view the preference model.

|===

=== *View*
[cols="1,1", options="header"] 
|===
|Method name
|Explanation 

|displayTabFolder()
|This will plug an instance of tabFolder to the mainshell and store it locally. The view decides then to whom the tabfolder is given. 

|buildEditionView()
|This methods returns an instance of EditionView. It builds an EditionView and pass it the tabfolder so that the view can plug itself on it. (This methods has a lot of chances to be called in displayGui() in the main GUI class).

|builVisualizationView()
|This methods returns an instance of Visualization. It builds an Visualization and pass it the tabfolder so that the view can plug itself on it. (This methods has a lot of chances to be called in displayGui() in the main GUI class).


|===

=== *VisualizationView*
[cols="1,1", options="header"] 
|===
|Method name
|Explanation 

|createVisualizationButtons()
|Creation and display buttons for displays in rows, columns and wrapped.

|createTable
|Creates an empty table and fill in it with preferences.

|displayRows
|Rows displaying preference

|displayColumns
|Columns displaying preference

|displayWrapped
|Wrapped displaying preference



|===

=== *EditionView*
[cols="1,1", options="header"] 
|===
|Method name
|Explanation 

|createEditionButtons()
|Creates and displays the different edit buttons. A button to select a profile, buttons to add or remove an alternative and buttons to add or remove a voter.

|displayProfil()
|Creates an editable "profile name" text field 

|displayVoters()
|Creates and displays the different text fields corresponding to the voters. The name can be changed.

|displayAlternatives()
|Creates and displays the different text fields corresponding to the voter's alternatives in order of preference. If an alternative is modified then this alternative is modified for each voter.


|===


